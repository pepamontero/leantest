\documentclass{article}

% Paquetes usados
\usepackage{graphicx} % Imágenes
\usepackage{amsmath} % Algunos símbolos matemáticos
\usepackage{amsfonts}
\usepackage{array} % Matrices, tablas
\usepackage{xcolor} % Colores de texto
%LEAN
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.8, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.0, 0.1, 0.9}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red
\definecolor{backgroundcolor}{rgb}{0.92, 0.92, 0.92} % light grey

% Distancias entre párrafos, quitar sangrías
\setlength{\parindent}{0pt}
\setlength{\parskip}{.8em}

% Espaciados entre palabras en el justificado.
\sloppy

% Título
\title{Formalización de las matemáticas con Lean. Un caso de estudio: Resultados de Topología General.}
\author{Pepa Montero Jimena}
\date{}

% Inline code
\usepackage{tikz}
\tikzset{%
    baseline,
    inner sep=2pt,
    minimum height=12pt,
    rounded corners=2pt  
}
\newcommand{\code}[1]{\mbox{% added this percent
    \ttfamily
    \tikz \node[anchor=base,fill=backgroundcolor]{#1};% added this percent
}}
\newcommand{\bluecode}[1]{\code{\textcolor{blue}{#1}}}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\newcommand{\redcode}[1]{\code{\textcolor{red}{#1}}}

% Lean code
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean, backgroundcolor=\color{backgroundcolor}} %default language  

% Spell checker settings
% spell-checker: disable


\begin{document}

\maketitle

\section{Introducción}

Introducción al trabajo.

\section{Lean Theorem Prover}

El proyecto Lean fue iniciado en 2012 por Leonardo de Moura, que formaba parte de Microsoft Research Redmond. Es un proyecto activo con una visión a largo plazo, y con miras en el potencial de automatización en las demostraciones matemáticas.\cite{avigad2015theorem}

Lean es un asistente de demostración, es decir, es un software que proporciona un lenguaje para definir objetos, especificar propiedades de esos objetos y probar que estas especificaciones se cumplen. El sistema comprueba que dichas pruebas son correctas y coherentes desde un punto de vista lógico. \cite{leanprover2024} 

Sin embargo, Lean es también un lenguaje de programación, en particular un lenguaje funcional basado en tipos dependientes. Lean 4 es el resultado de volver a implementar el asistente de demostración de Lean 3 en el propio lenguaje de Lean. El nuevo compilador produce código en C, lo que permite a los usuarios implementar automatizaciones de pruebas en Lean de manera eficiente, compilar estas automatizaciones a C y añadirlas como plugins\cite{moura2021lean}.

El objetivo del proyecto Lean es reducir la distancia entre demostraciones matemáticas asistidas y automatizadas, integrando herramientas y métodos automatizados en un marco que facilita la interacción con el usuario y la construcción de pruebas axiomáticas completamente especificadas\cite{avigad2015theorem}.

\subsection{Teoría de tipos dependientes}

[No se hasta qué punto desarrollar este apartado]

Para ambos aspectos de Lean es importante entender la teoría de tipos dependientes en la que se basa. En esta teoría, cada expresión tiene un "tipo" asociado. Por ejemplo, una variable "x" puede hacer referencia a un número natural en un contexto y a un número real en otro.

En Lean podemos declarar variables de un tipo determinado utilizando el operador \code{:}. Por ejemplo \code{n : $\mathbb{N}$} \footnote{Podemos escribir $\mathbb{N}$ en Lean escibiendo \code{$\backslash$nat} y después pulsando espacio.} quiere decir que $n$ es un número natural.

Ejemplos:

\begin{lstlisting}
  variable (n : ℕ)
  variable (f : ℕ → ℕ)
  variable (g : ℕ → ℕ × ℕ)
  variable (p q : ℚ) -- puedo definir varias variables del mismo tipo a la vez
\end{lstlisting}

\code{A → B}

Podemos utilizar entonces el comando \bluecode{$\#$check} para ver que interpreta Lean en cada caso. 

\begin{lstlisting}
  #check n            -- output: n : ℕ
  #check f            -- output: f : ℕ → ℕ
  #check f 2            -- output: f 2 : ℕ
  #check (p, q)            -- output: (p, q) : ℚ × ℚ
\end{lstlisting}

TIPO PROP

Un tipo a destacar en Lean es el tipo \bluecode{Prop}. Un objeto de tipo \bluecode{Prop} es una expresión lógica, que puede tomar los valores verdadero o falso, y se puede operar con los conectores lógicos que conocemos. Podemos declarla como cualquier otra:

\begin{lstlisting}
  variable (P Q : Prop)
  #check P            -- output: P : Prop
  #check ¬P            -- output: ¬P : Prop
  #check P ∧ Q            -- output: P ∧ Q : Prop
\end{lstlisting}

También podemos declarar nuevos tipos y construcciones sobre tipos. Ejemplo:

\begin{lstlisting}
  variable (X : Type)
  variable (F : Type → Type)
  #check F ℕ            -- output: F ℕ : Type
\end{lstlisting}

"Tipo" es un tipo en si mismo.* Jerarquía de tipos. Necesario explicar?

* Tipos dependientes : lista de reales vs. lista de enteros?




\subsection{Lean como asistente de demostración}

Para nuestro fin, nos centraremos en la función de asistente de demostración de Lean. A continuación vamos a introducir las herramientas principales que utilizaremos a la hora de formalizar resultados en Lean 4.



\subsubsection{Definiciones}

Podemos definir constantes en Lean utilizando el comando \bluecode{def} y el operador \code{:=}. Por ejemplo:

\begin{lstlisting}
  def x : ℕ := 2
  def X : Type := ℕ
\end{lstlisting}

Cuando hacemos definiciones también podemos declarar el tipo de objeto que estamos definiendo. Esto no es necesario siempre, porque Lean puede, en general, inferir el tipo directamente.

\begin{lstlisting}
  #check X            -- output: X : Type
  def Y := ℝ
  #check Y            -- output: Y : Type
\end{lstlisting}

\begin{lstlisting}
  def y := 0
  #check y            -- output: y : ℕ
  def z := (0 : ℝ)
  #check z            -- output: z : ℝ
\end{lstlisting}

También podemos definir funciones utilizando el operador \bluecode{fun} (o \bluecode{$\lambda$}), y evaluar estas funciones en elementos concretos utilizando \bluecode{$\#$eval}.

\begin{lstlisting}
  def f : ℕ → ℕ := fun x ↦ x + 5
  def g : ℕ → Prop :=  λ x ↦ x > 0

  #eval f 4            -- output: 9
  #eval f x            -- output: 7
  #eval g 2            -- error: no sabe decidir inmediatamente si 2 > 0
\end{lstlisting}


\subsubsection{Resultados}

Un resultado consiste de varios elementos: el tipo de enunciado (ejemplo, lema o teorema), un nombre, unas hipótesis y una tesis.

Para diferenciar el tipo de enunciado utilizaremos las palabras clave \bluecode{example}, \bluecode{lemma} y \bluecode{theorem} [no se si hay alguno más]. Los resultados de tipo ejemplo no se identifican con un nombre. En el caso de los lemas y los teoremas, el nombre se escribe directamente detrás de la palabra clave.

Las hipótesis, que son opcionales, se escriben después del nombre, utilizando paréntesis para separarlas entre sí. Las hipótesis incluyen objetos que se inicializan (ej. "Sea $n \in \mathbb{N}$" se podría escribir como \code{(n : $\mathbb{N}$)}) y también hipótesis propiamente dichas que suponemos como ciertas. Estas últimas necesitan un nombre seguido de \code{:} (ej. "Supongamos que $n > 0$" se podría escribir como \code{(hn : n > 0)}).

A su vez, utilizamos los dos puntos \code{:} para separarlas de la tesis, que se escribe a continuación.

Al final de la expresión escribimos \code{:=}, y después de este símbolo escribiremos la demostración del enunciado. Por ahora ignoraremos esa parte.

Ejemplos:

\begin{lstlisting}
  example : 2 + 2 = 4 := ...

  lemma my_obvious_lemma (P : Prop) : P → P := ...

  theorem modus_ponens (P Q : Prop) (hP : P) (hPQ : P → Q) : Q := ...

  lemma i_am_error (P Q : Prop) (h : P) : Q := ... 
\end{lstlisting}

En el último ejemplo quería destacar que Lean no pone ninguna pega a un resultado que no sea cierto, este último resultado no dará ningún error (salvo un mensaje de que queda por demostrar). Lean no comprueba la veracidad de los enunciados, sólo comprueba si la demostración a continuación es correcta.

\subsubsection{Mathlib}

[No se donde poner esta sección si antes de defs y resultados o despues o incluso dentro de pruebas??]

La librería de matemáticas de Lean, \textit{Mathlib}, es un proyecto colaborativo con el objetivo de construir una base de datos unificada de definiciones y resultados matemáticos formalizadas en el lenguaje Lean, y cuenta con numerosos colaboradores habituales y actividad diaria\cite{leanprover2024}.

Cómo utilizamos Mathlib?? <- esto es importante

Keywords: exact?, apply?, rw?

Todas sirven para buscar en la librería de mathlib (o en los resultados anteriores que hayamos escrito nosotros) y aplicar la táctica correspondiente.

\subsubsection{Pruebas}

[Muchos ejemplos de esta parte en cierto sentido están sacados del curso de Buzzard y demás. No se como debería escribir esas citas xd]

En Lean, existen dos formas de formalizar demostraciones: utilizando términos y utilizando tácticas. Una prueba es un objeto de tipo \bluecode{Proof}. Un término de tipo \bluecode{Proof} es una representación de una demostración matemática de la veracidad de un enunciado.

Para el objetivo de este trabajo, nos vamos a centrar en las demostraciones que utilizan tácticas. Una demostración de tipo táctico en Lean consiste en una sucesión de comandos o instrucciones, a las que llamamos tácticas, que describen cómo se construye la demostración.

Una vez hemos descrito un resultado o enunciado en Lean, si después de \code{:=} escribimos la palabra clave \bluecode{by}, entraremos en lo que llamamos \textit{modo táctico}. El modo táctico tiene dos particularidades:

Por un lado, contamos en nuestro editor con una nueva ventana llamada \textit{Lean Infoview} que ahora mostrará una lista de elementos. Por ejemplo, si en nuestro archivo lean tenemos lo siguiente

\begin{lstlisting}
  theorem modus_ponens (P Q : Prop) (hP : P) (hPQ : P → Q) : Q := by
\end{lstlisting}

En el infoview ahora veremos lo siguiente:

\begin{lstlisting}
  P Q : Prop
  hP : P
  hPQ : P → Q
  ⊢ Q
\end{lstlisting}

Las tres primeras líneas se corresponden con las hipótesis de nuestro enunciado. La última línea, que siempre comienza con el símbolo \code{$\vdash$}, muestra nuestra tesis, es decir, lo que queremos demostrar en este momento.

Cuando aplicamos una táctica (escribimos un comando) las hipótesis y/o la tesis se actualizan automáticamente en el infoview. Aplicando una táctica detrás de otra, queremos modificar la tesis hasta llegar a algo que es cierto trivialmente. En este caso, el infoview mostrará el mensaje \code{No goals}. Sabremos entonces que hemos completado la prueba correctamente.

En general, y sobretodo en los casos sencillos, existe una relación bastante clara entre estos comandos (tácticas) y las expresiones que utilizamos en las demostraciones formales a las que estamos acostumbrados.

A continuación vamos a ver una a una las tácticas que más se utilizan en las demostraciones.

[NOTA : NO SE SI HACERLO COMO ESTÁ O DEFINIR LAS VARIABLES AL PRINCIPIO NO SE QUE ES MENOS LIOSO]

\begin{itemize}
    \item \textbf{\blue{intro}}
\end{itemize}
    
Imaginemos que queremos demostrar un resultado del estilo de "Si A, entonces B". Normalmente, empezaríamos la demostración diciendo "Supongamos que se da A. Veamos que entonces se tiene B".

En el modo táctico, utilizamos la táctica \bluecode{intro} con esta finalidad. Si en el infoview tenemos

\begin{lstlisting}
  A B : Prop
  ⊢ A → B
\end{lstlisting}

Y escribimos \code{\blue{intro} hA}, donde \code{hA} es el nombre que le queremos dar a la nueva hipótesis, obtendremos

\begin{lstlisting}
  A B : Prop
  hA : A        -- supongamos A
  ⊢ B           -- queremos ver si B
\end{lstlisting}

Por ejemplo, la demostración de nuestro lema \code{my\_obvious\_lemma} debería empezar de la siguiente forma

\begin{lstlisting}
  lemma my_obvious_lemma (P : Prop) : P → P := by
    intro hP
    sorry
\end{lstlisting}

Otra forma de utilizar \bluecode{intro} es en las expresiones de la forma "Para todo $x \in X$, $x$ tiene la propiedad $P$". Normalmente, empezaríamos diciendo "sea un $x \in X$ fijo pero arbitrario... veamos que $x$ satisface $P$".

También utilizaremos \bluecode{intro} en este caso. Si tenemos

\begin{lstlisting}
  P : X → Prop
  ⊢ ∀ (x : X), P x
\end{lstlisting}

y utilizamos \code{\blue{intro} x}, donde \code{x} es la nueva variable que vamos a definir, obtendremos

\begin{lstlisting}
  P : X → Prop
  x : X       -- sea x ∈ X
  ⊢ P x       -- veamos que x cumple P
\end{lstlisting}

\begin{itemize}
  \item \textbf{\textcolor{red}{sorry}}
\end{itemize}

Notemos que en el apartado anterior, la demostración de \code{my\_obvious\_lemma} termina con \redcode{sorry}. Esta es una táctica también, que indica a Lean que la demostración no está terminada, pero que no queremos terminarla por ahora.

Lean mostrará sobre los resultados que acaben en \redcode{sorry} la advertencia \code{declaration uses sorry}. Podemos utilizar resultados incompletos en otras pruebas, pero estas pruebas también estarán marcadas como incompletas.

\begin{itemize}
  \item \textbf{\blue{exact}}
\end{itemize}

Otra táctica fundamental es \bluecode{exact}. Usamos \bluecode{exact} cuando nuestra tesis sea literalmente igual o igual por definición\footnote{Para Lean, literalmente igual es lo mismo que igual por definición.} a una de nuestras hipótesis.

Con esta nueva táctica podemos terminar nuestra demostración de \code{my\_obvious\_lemma}; como en el infoview tenemos, despuñes de utilizar \code{\blue{intro} hP},

\begin{lstlisting}
  P : Prop
  hP : P
  ⊢ P
\end{lstlisting}

Enotnces podemos utilizar \code{\blue{exact} hP} para terminar.

\begin{lstlisting}
  lemma my_obvious_lemma (P : Prop) : P → P := by
    intro hP
    exact hP
\end{lstlisting}

Ahora, en el infoview obtendremos el mensaje \code{No goals}.

Veamos un ejemplo en el que en vez de tener una hipótesis literalmente igual que nuestra tesis, es igual por definición. Consideramos el resultado

\begin{lstlisting}
  example (A B : Set X)
      (x : X) (hx : x ∈ A ∧ x ∈ B) :
      x ∈ A ∩ B := by sorry
\end{lstlisting}

Tenemos un tipo $X$, subconjuntos $A, B \subset X$ y un elemento $x \in X$. Suponemos que $x \in A \land x \in B$ (\code{hx}). Queremos ver que $x \in A \cap B$. Pero, en Lean, $x \in A \cap B$ está definido como $x \in A \land x \in B$, luego realmente tenemos lo mismo. El resultado anterior se puede demostrar, por tanto, utilizando simplemente

\begin{lstlisting}
  example (A B : Set X)
      (x : X) (hx : x ∈ A ∧ x ∈ B) :
      x ∈ A ∩ B := by
    exact hx
\end{lstlisting}



\begin{itemize}
  \item \textbf{\blue{rfl}}
\end{itemize}

Utilizamos \bluecode{rfl} cuando tenemos en el objetivo una expresión con una igualdad, una doble implicación o cualquier otra relación de equivalencia, en la que los términos a ambos lados son exactamente iguales (o iguales por definición). Consiste en aplicar la propiedad reflexiva ($x \cong x$) de las relaciones de equivalencia.

Ejemplos:

\begin{lstlisting}
  example (x : X) : x = x := by
    rfl
\end{lstlisting}

\begin{lstlisting}
  example (A B : Set X) (x : X) :
      (x ∈ A ∪ B) ↔ (x ∈ A ∨ x ∈ B) := by
    rfl
\end{lstlisting}

\begin{itemize}
  \item \textbf{\blue{trivial}}
\end{itemize}

La táctica \bluecode{trivial} se utiliza cuando el objetivo es \bluecode{True} o igual a \bluecode{True} por definición. Ejemplos:

\begin{lstlisting}
  example : True := by
    trivial
\end{lstlisting}

En Lean, existe un subconjunto especial, el \code{Set.univ}, que contiene a todos los elementos del tipo asociado; es el universo, el todo. Por tanto, si $x \in X$, entonces \code{$x \in$ Set.univ} está definido simplemente como \bluecode{True}.

\begin{lstlisting}
  example (x : X) : x ∈ Set.univ := by
    trivial
\end{lstlisting}



\begin{itemize}
  \item \textbf{\textcolor{blue}{apply}}
\end{itemize}

La táctica \bluecode{apply} consiste en aplicar Modus Ponens. Si quiero demostrar B, y tengo como hipótesis "A implica B", entonces basta con demostrar A.

Es decir, si en el infoview tengo algo de la forma

\begin{lstlisting}
  P Q : Prop
  hPQ : P → Q
  ⊢ Q
\end{lstlisting}

y utilizo \code{\blue{apply} hPQ}, paso a tener P como objetivo:

\begin{lstlisting}
  P Q : Prop
  hPQ : P → Q
  ⊢ P
\end{lstlisting}

Con esto, ya podemos demostrar nuestro teorema \code{modus\_ponens}

\begin{lstlisting}
  theorem modus_ponens (P Q : Prop) (hP : P) (hPQ : P → Q) : Q := by
    apply hPQ
    exact hP
\end{lstlisting}

Notar que \bluecode{apply} también sirve para expresiones que aunque no sean implicaciones, son iguales a implicaciones por definición. Por ejemplo, en Lean, $A \subset B$ está definido como $x \in A \implies x \in B$. Por tanto, si tenemos en el infoview

\begin{lstlisting}
  A B : Set X
  x : X
  h : A ⊆ B
  ⊢ x ∈ B
\end{lstlisting}

Podemos utilizar \code{\blue{apply} h}, y la tesis pasará a ser

\begin{lstlisting}
  ⊢ x ∈ A
\end{lstlisting}

% ejemplos apply

También podemos usar apply en otra hipótesis utilizando la palabra clave \blue{at}. Por ejemplo, supongamos que tenemos las hipótesis

\begin{lstlisting}
  hP : P
  hPQ : P → Q
\end{lstlisting}

Aplicar \code{\blue{apply} hPQ \blue{at} hP}, actualizaría las hipótesis a

\begin{lstlisting}
  hP : Q
  hPQ : P → Q
\end{lstlisting}



\begin{itemize}
  \item \textbf{\blue{by\_contra}}
\end{itemize}

Esta táctica es equivalente a utilizar el método de reducción al absurdo. Al utilizarla, añade una nueva hipótesis, resultante de negar la tesis, y la tesis pasa a ser \bluecode{False}.

Por ejemplo, si tenemos en el infoview

\begin{lstlisting}
  ⊢ P
\end{lstlisting}

y aplicamos \code{\blue{by\_contra} h}, ahora tendremos

\begin{lstlisting}
  h : ¬P
  ⊢ False
\end{lstlisting}

Para llegar a demostrar False, necesitaremos tener dos hipótesis que sean contradictorias (lo que normalmente conocemos como "llegar a una contradicción"), utilizaremos entonces "exact h1 h2", donde h1 siempre debe ser la negación natural de h2 (y no al revés).

% ejemplos by_contra

Notar que si una de mis hipótesis es False (o igual a False por definición), entonces puedo demostrar cualquier cosa utilizando by\_contra. (último ejemplo)

\subsubsection{Resumen de las tácticas básicas}

% TABLA CON LAS TÁCTICAS
% poner bien el ancho de las filas :/

[Esto igual debería ir en un anexo? no se]

\renewcommand{\arraystretch}{2}

\begin{center}
\begin{tabular}{|  m{8em}  |m{8em} |m{8em}  |} 
  \hline
  \textbf{antes} & \textbf{táctica} & \textbf{después} \\
  \hline
  $\vdash$ P $\rightarrow$ Q & intro hP & \parbox{8em}{hP : P \\ $\vdash$ Q} \\ 
  \hline
  $\vdash \forall$x : X, P x & intro x &  \parbox{8em}{x : X \\ $\vdash$ P x} \\ 
  \hline
  \parbox{8em}{h : P \\ $\vdash$ P}& exact h & No goals\\ 
  \hline
  $\vdash$ x = x & rfl & No goals\\ 
  \hline
  $\vdash$ x $\leftrightarrow$ x & rfl & No goals\\ 
  \hline
  $\vdash$ True & trivial & No goals \\ 
  \hline
  \parbox{8em}{h : P $\rightarrow$ Q \\ $\vdash$ Q} & apply h & $\vdash$ P\\ 
  \hline
  \parbox{8em}{h1 : P $\rightarrow$ Q \\ h2 : P} & apply h1 at h2 & h2 : Q\\ 
  \hline
  $\vdash$ P & by\_contra h & \parbox{8em}{h : $\neg$ P \\ $\vdash$ False} \\\hline
\end{tabular}
\end{center}

Pasamos a ver otras tácticas más avanzadas.

\subsubsection{Simplificar expresiones}

rw y simp, dsimp

\subsection{Trabajar con varias tesis a la vez}

En ocasiones tendremos varias tesis en vez de sólo una (en la siguiente sección podemos ver varios ejemplos en los que esto ocurre). En este caso, podremos ver arriba del InfoView el número de tesis activas que tenemos, y a continuación veremos la primera tesis, seguida de la siguiente.

Para poder trabajar sólo con una tesis a la vez (menos congestión visual), podemos separar las tesis utilizando puntos : · (alt+3). Ejemplo: (poner imagen de como se ve el InfoView)

\subsubsection{Trabajar con conectores lógicos}

En muchas ocasiones estaremos trabajando con los conectores $\land, \lor, \leftrightarrow$. Podemos utilizar varias tácticas para facilitar esta tarea.

\begin{itemize}
    \item \textbf{left, right}
\end{itemize}

Para tesis de la forma "A ó B" basta demostrar que se da A (análogamente, basta demostrar que se da B). Para esto, utilizamos la táctica "left" (respectivamente "right"). Es decir, le comunico a Lean que me voy a centrar sólo en la parte izquierda (resp. derecha) del "ó".

% ejemplos left, right

Notar que, en el último ejemplo, como x in A union B es equivalente a x in A or x in B por definición, podemos utilizar right directamente.

Además, en hipótesis de la forma A $\land$ B, podemos querer utilizar sólo A (ó sólo B). Podemos utilizar h.left (h.right), respectivamente.

\begin{itemize}
    \item \textbf{cases'}
\end{itemize}

La táctica "cases'"\footnote{existe una táctica cases pero es menos potente que esta, y esta es la que utilizaremos normalmente} se utiliza sobre una hipótesis de la forma "P $\lor$ Q", y queremos proceder de forma distinta en caso de que P y de que Q.

Es el equivalente a dividir una demostración en casos en el lenguaje natural. Movida: esto genera varios goals. Esto habría que explicarlo bien. Poner que gestionamos los distintos goals con · ?

Esta táctica también tiene otro uso práctico interesante para $\land$ : si se aplica a una hipótesis de la forma "P $\land$ Q", dividimos esta hipótesis en dos. Esto nos puede servir en ocasiones para simplificar las hipótesis y trabajar más fácilmente con ellas.

\begin{itemize}
    \item \textbf{constructor}
\end{itemize}

Podemos utilizar costructor cuando tengamos tesis que se puedan separar en dos partes, por ejemplo tesis de la forma "P $\land$ Q" se convierten en dos tesis distintas, por un lado P y por otro Q. Igualmente, tesis de la forma "P $\leftrightarrow$ Q" se divide en "P $\rightarrow$ Q" y "Q $\rightarrow$ P".


\begin{center}
\begin{tabular}{ | m{8em} | m{8em}| m{8em} | } 
  \hline
  \textbf{antes} & \textbf{táctica} & \textbf{después} \\
  \hline
  $\vdash$ P $\lor$ Q & left & $\vdash$ P \\
  \hline
  $\vdash$ P $\lor$ Q & right & $\vdash$ Q \\
  \hline
  \parbox{8em}{h : P $\lor$ Q \\ $\vdash$ goal} & cases' h with hP hQ & \parbox{8em}{goal 1: \\ hP : P \\ $\vdash$ goal \\[1ex] goal 2: \\ $~~$ hQ : Q \\ $~~$ $\vdash$ goal} \\
  \hline
  h : P $\land$ Q & cases' h with hP hQ & \parbox{8em}{hP : P \\ hQ : Q }\\
  \hline
  
\end{tabular}
\end{center}

% Bibliografía

\bibliographystyle{plain}
\bibliography{references.bib}

\end{document}
